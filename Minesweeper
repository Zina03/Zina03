// Minesweeper.h

#pragma once

#include <Windows.h>
#include <iostream>
#include <iomanip>
#include <conio.h>
#include <conio.h>
#include <cstring>
#include <cstdio>
#include <cwchar>
#include <ctime>
#include <ios>

#define _CRT_SECURE_NO_WARNINGS
#define SEPARATOR_HASHTAG 	std::cout << std::setw(173) << std::setfill('#') << '#' << std::endl;
#define SEPARATOR_LINE 	std::cout << std::setw(175) << std::setfill('_') << " \n\n";

#define SEPARATOR_Input(s) 	std::cout << std::setw(s) << std::setfill(' ') << " => ";
#define INDENT_space(s) 	std::cout << std::setw(s) << std::setfill(' ') << ' ';
#define INDENT_(s) 	std::cout << std::setw(s) << std::setfill(' ');

#define Clear_Field  system("cls");
#define EndLine  std::cout << std::endl;
#define Sound 	std::cout << "\a";

// Цвета 
#define Blue_Black  system("color 10");
#define Green_Black  system("color 20");
#define Aqua_Black  system("color 30");
#define Red_Black  system("color 40");
#define Purple_Black  system("color 50");
#define Black_Blue  system("color 0b");
#define Black_White  system("color 0F");
#define White_Red  system("color F4");

enum SelectLanguage
{
	Russian = 0,
	English,
};

enum SelectMode
{
	Easy = 1,
	Medium,
	Hard,
};

enum SelectSize
{
	Ten = 1,
	Fifteen,
	Twenty,
};

enum Select_cell
{
	Select_cell = 0,
	Put_flag,
	Remove_flag,
};

template<typename T>
auto Create_array(size_t, T**);

template<typename T>
auto Delete_array(size_t, T**);

void EpilepsyTime(const char*);  // Веселая загрузка игры 

void SuperMario();// Звук
void MissionImposibble_sound(); // Звук

void OkrasAutorAndInstr(char map[][70], int color, int str);// Окрашивание пункта Finish_Game
void printStuff(int, int); // Окрашивание пункта Finish_Game
void Finish_Game(bool); // Функция отображения автора

void Wrong();  // Когда пользователь допустил ошибку при наборе текста

void Create_GameField(size_t, char**, char**, bool**); // Создание игрового поля. Заполнение определенными символами

void SetMina(int mina, size_t, char**, bool**, short, short); // Рандомизируем мины вокруг поля

bool Check_coordinats(size_t, char&, short); // Проверка координатов

void Display_GameField(size_t, char**, bool, short&); // Отображение игрового поля или же поля с минами для админа

void MakeVerticalSpace(short, short, size_t, char**, char**); // Добавляем пустоту
void MakeHorizontalSpace(short, short, size_t, char**, char**);// Добавляем пустоту
void MakeDiaqonalSpace(short, short, size_t, char**, char**);// Добавляем пустоту

void MakeSpace(short, short, size_t, char**, char**);// Добавляем пустоту
bool IsWinner(size_t, char**, char**); // Проверка на победу
bool Impact(short, short, size_t, char**, char**); // Выстрелы в клетку

void Deleting_GameOptions(size_t, char**, char**, bool**); // Удаление данных

// Minesweeper.cpp

#include "Minesweeper.h"

template<typename T>
auto Create_array(size_t size, T** arr)
{
	for (size_t i = 0; i < size; i++)
	{
		arr[i] = new T[size];
	}
}

template<typename T>
auto Delete_array(size_t size, T** arr)
{
	for (size_t i = 0; i < size; i++)
	{
		delete[] arr[i];
	}
	delete[] arr;
}

void EpilepsyTime(const char* text) // Веселая загрузка игры 
{
	SEPARATOR_LINE;
	SEPARATOR_HASHTAG; SEPARATOR_HASHTAG;
	EndLine;

	INDENT_space(75); std::cout << "FLASHLIGHTS WARNING"; EndLine;

	EndLine;
	SEPARATOR_HASHTAG; SEPARATOR_HASHTAG;
	SEPARATOR_LINE;

	Sleep(1500);

	Clear_Field;
	SEPARATOR_HASHTAG; SEPARATOR_HASHTAG;
	EndLine;

	INDENT_space(82 - strlen(text) / 2); std::cout << text;

	Sleep(750);

	int disco_time = 0;

	for (int i = 0; i < 36; i++)
	{
		if (disco_time == 2)
		{
			Beep(1000, 300);
			Blue_Black; Sleep(80);
		}
		else if (disco_time == 4)
		{
			Beep(1034, 200);
			Green_Black; Sleep(80);
		}
		else if (disco_time == 6)
		{

			Aqua_Black; Sleep(80);
		}
		else if (disco_time == 8)
		{
			Beep(1000, 300);
			Red_Black; Sleep(80);
		}
		else if (disco_time == 10)
		{
			Beep(1034, 200);
			Purple_Black;
			std::cout << '.';
			disco_time = 0;
		}
		disco_time++;
	}

	Sound; EndLine;
	Black_Blue;
	Sleep(500);
	Clear_Field;
}

void SuperMario()
{
	Beep(659, 125); Beep(659, 125); Sleep(125); Beep(659, 125); Sleep(167);
	Beep(523, 125); Beep(659, 125); Sleep(125); Beep(784, 125); Sleep(375);
	Beep(392, 125); Sleep(375); Beep(523, 125); Sleep(250);
	Beep(392, 125); Sleep(250); Beep(330, 125); Sleep(250);
	Beep(440, 125); Sleep(125); Beep(494, 125); Sleep(125);
	Beep(466, 125); Sleep(42); Beep(440, 125); Sleep(125);
	Beep(392, 125); Sleep(125); Beep(659, 125); Sleep(125);
	Beep(784, 125); Sleep(125); Beep(880, 125); Sleep(125);
	Beep(698, 125); Beep(784, 125); Sleep(125); Beep(659, 125); Sleep(125);
	Beep(523, 125); Sleep(125); Beep(587, 125); Beep(494, 125); Sleep(125);
	Beep(523, 125); Sleep(250); Beep(392, 125); Sleep(250);
	Beep(330, 125); Sleep(250); Beep(440, 125); Sleep(125);
	Beep(494, 125); Sleep(125); Beep(466, 125); Sleep(42);
	Beep(440, 125); Sleep(125); Beep(392, 125); Sleep(125);
	Beep(659, 125); Sleep(125); Beep(784, 125); Sleep(125);
	Beep(880, 125); Sleep(125); Beep(698, 125); Beep(784, 125); Sleep(125);
	Beep(659, 125); Sleep(125); Beep(523, 125); Sleep(125);
	Beep(587, 125); Beep(494, 125); Sleep(375); Beep(784, 125); Beep(740, 125);
	Beep(698, 125); Sleep(42); Beep(622, 125); Sleep(125);
	Beep(659, 125); Sleep(167); Beep(415, 125); Beep(440, 125); Beep(523, 125); Sleep(125);
	Beep(440, 125); Beep(523, 125); Beep(587, 125); Sleep(250); Beep(784, 125); Beep(740, 125); Beep(698, 125); Sleep(42);
	Beep(622, 125); Sleep(125); Beep(659, 125); Sleep(167); Beep(698, 125); Sleep(125);
	Beep(698, 125); Beep(698, 125); Sleep(625); Beep(784, 125); Beep(740, 125); Beep(698, 125); Sleep(42);
	Beep(622, 125); Sleep(125); Beep(659, 125); Sleep(167);
	Beep(415, 125); Beep(440, 125); Beep(523, 125); Sleep(125); Beep(440, 125); Beep(523, 125); Sleep(250);
	Beep(622, 125); Sleep(250); Beep(587, 125); Sleep(250); Beep(523, 125); Sleep(1125);
	Beep(784, 125); Beep(740, 125); Beep(698, 125); Sleep(42); Beep(622, 125); Sleep(125); Beep(659, 125); Sleep(167);
	Beep(415, 125); Beep(440, 125); Beep(523, 125); Sleep(125); Beep(440, 125); Beep(523, 125); Beep(587, 125); Sleep(250);
	Beep(784, 125); Beep(740, 125); Beep(698, 125); Sleep(42); Beep(622, 125); Sleep(125); Beep(659, 125); Sleep(167);
	Beep(698, 125); Sleep(125); Beep(698, 125); Beep(698, 125); Sleep(625); Beep(784, 125); Beep(740, 125); Beep(698, 125); Sleep(42);
	Beep(622, 125); Sleep(125); Beep(659, 125); Sleep(167); Beep(415, 125); Beep(440, 125); Beep(523, 125); Sleep(125);
	Beep(440, 125); Beep(523, 125); Beep(587, 125); Sleep(250); Beep(622, 125); Sleep(250); Beep(587, 125); Sleep(250);
	Beep(523, 125); Sleep(625);
}
void MissionImposibble_sound()
{
	Beep(784, 150); Sleep(300); Beep(784, 150); Sleep(300);
	Beep(932, 150); Sleep(150); Beep(1047, 150); Sleep(150);
	Beep(784, 150); Sleep(300); Beep(784, 150); Sleep(300);
	Beep(699, 150); Sleep(150); Beep(740, 150); Sleep(150);
	Beep(784, 150); Sleep(300); Beep(784, 150); Sleep(300);
	Beep(932, 150); Sleep(150); Beep(1047, 150); Sleep(150);
	Beep(784, 150); Sleep(300); Beep(784, 150); Sleep(300);
	Beep(699, 150); Sleep(150); Beep(740, 150); Sleep(150);
	Beep(932, 150); Beep(784, 150); Beep(587, 1200); Sleep(75);
	Beep(932, 150); Beep(784, 150); Beep(554, 1200); Sleep(75);
	Beep(932, 150); Beep(784, 150); Beep(523, 1200); Sleep(150);
	Beep(466, 150); Beep(523, 150);
}

void OkrasAutorAndInstr(char map[][70], int color, int str)
{
	HANDLE consoleOutput;
	consoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);

	for (int i = 0; i < str; i++) {
		for (int j = 0; j < 70; j++) {
			SetConsoleTextAttribute(consoleOutput, color); //Перед строкой для выделения текста цветом
			std::cout << map[i][j];
			SetConsoleTextAttribute(consoleOutput, 15); //Возвращаем назад цвет
		}
		EndLine;
	}
}
void printStuff(int x, int y)// Обновление экрана
{
	// Sleep(95);
	HANDLE hd = GetStdHandle(STD_OUTPUT_HANDLE);
	COORD cd;
	cd.X = x;
	cd.Y = y;
	SetConsoleCursorPosition(hd, cd);
}
void Finish_Game(bool win) // Функция отображения автора
{
	if (win)
	{
		char map[70][70]
		{
				"",
				"                               o                ||  ",
				"                                                ||  ",
				"      \\\\      //\\\\      //    ||    ||\\\\   ||   ||  ",
				"       \\\\    //  \\\\    //     ||    || \\\\  ||   ||  ",
				"        \\\\  //	  \\\\  //      ||    ||  \\\\ ||	||    ",
				"         \\\\//	   \\\\//	      ||    ||   \\\\||    o  ",
				"                                            ",
				"                                            ",

				"",

		};
		int time = 3;
		while (time--)
		{
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 12, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 6, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 14, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 10, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 11, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 9, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 13, 11);
			printStuff(0, 0);
			printStuff(0, 0);
		}
	}
	else
	{
		char map[70][70]
		{
				"",
				"                                      ___      ________    ||     ",
				"     ||              //\\\\            //\\\\     ||________|  || ",
				"     ||             //  \\\\          //  \\\\    ||           || ",
				"     ||            //    \\\\        //         ||           ||   ",
				"     ||           //      \\\\        \\\\        ||________   || ",
				"     ||           \\\\      //         \\\\       ||________|  || ",
				"     ||            \\\\    //      \\\\   \\\\      ||           ||",
				"     ||________     \\\\  //        \\\\  //      ||________  ",
				"     ||________|     \\\\//          \\\\//       ||________|   o",
				"                                                               ",

				"",
		};

		int time = 3;
		while (time--)
		{
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 12, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 6, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 14, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 10, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 11, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 9, 11);
			printStuff(0, 0);
			OkrasAutorAndInstr(map, 13, 11);
			printStuff(0, 0);
			printStuff(0, 0);
		}
	}
	EndLine; EndLine; EndLine; EndLine; EndLine; EndLine; EndLine;
	EndLine; EndLine; EndLine; EndLine; EndLine; EndLine; EndLine;
}

void Wrong()
{
	for (int i = 0; i < 6; i++) // Мигает двумя цветами
	{
		if (i % 2 == 0)
		{
			Red_Black; Sleep(150);
		}
		else
		{
			Black_Blue; Sleep(150);
		}
	}
}

void Create_GameField(size_t size, char** Field, char** MinaBoard, bool** HiddenField) // Создание игрового поля. Заполнение определенными символами
{
	// Создаем двумерные динамические массивы
	Create_array(size, Field);
	Create_array(size, MinaBoard);
	Create_array(size, HiddenField);

	char symbol = 2;// символ смайлика

	for (int i = 0; i < size; i++) // Добавляем начальные эллэменты массиву
	{
		for (int j = 0; j < size; j++)
		{
			Field[i][j] = symbol;
			MinaBoard[i][j] = ' ';
			HiddenField[i][j] = 0;
		}
	}
}

void SetMina(int mina, size_t size, char** MinaBoard, bool** HiddenField, short vertical, short horizontal)
{
	HiddenField[vertical][horizontal] = 1;

	for (int i = 0; i < mina;)
	{
		int x = rand() % size; // случайные числа из диапазона 0 <-> size
		int y = rand() % size; // случайные числа из диапазона 0 <-> size

		if (!HiddenField[x][y])
		{
			HiddenField[x][y] = 1;
			i++;
		}
	}

	HiddenField[vertical][horizontal] = 0;

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (HiddenField[i][j] == 1)
			{
				MinaBoard[i][j] = 2; // Добавляет мину (смайлик)
			}
		}
	}

	vertical = 0;
	horizontal = 0;

	int count = 0; // количество мин вокруг одной ячейки
	bool flag = true;

	// Добавляет количество мин в окружении одной клетки

	do
	{
		count = 0;
		if (!HiddenField[vertical][horizontal])
		{
			if (vertical == 0)
			{
				if (horizontal == 0)
				{
					count = HiddenField[vertical + 1][horizontal] + HiddenField[vertical][horizontal + 1] + HiddenField[vertical + 1][horizontal + 1];
				}
				else if (horizontal > 0 && horizontal < size - 1)
				{
					count = HiddenField[vertical][horizontal - 1] + HiddenField[vertical + 1][horizontal - 1] + HiddenField[vertical + 1][horizontal] + HiddenField[vertical][horizontal + 1] + HiddenField[vertical + 1][horizontal + 1];
				}
				else
				{
					count = HiddenField[vertical][horizontal - 1] + HiddenField[vertical + 1][horizontal - 1] + HiddenField[vertical + 1][horizontal];
				}
			}
			else if (vertical > 0 && vertical < size - 1)
			{
				if (horizontal == 0)
				{
					count = HiddenField[vertical - 1][horizontal] + HiddenField[vertical + 1][horizontal] + HiddenField[vertical - 1][horizontal + 1] + HiddenField[vertical][horizontal + 1] + HiddenField[vertical + 1][horizontal + 1];

				}
				else if (horizontal > 0 && horizontal < size - 1)

				{
					count = HiddenField[vertical - 1][horizontal - 1] + HiddenField[vertical - 1][horizontal] + HiddenField[vertical - 1][horizontal + 1] + HiddenField[vertical][horizontal - 1] + HiddenField[vertical][horizontal + 1] + HiddenField[vertical + 1][horizontal - 1] + HiddenField[vertical + 1][horizontal] + HiddenField[vertical + 1][horizontal + 1];
				}
				else
				{
					count = HiddenField[vertical - 1][horizontal - 1] + HiddenField[vertical - 1][horizontal] + HiddenField[vertical][horizontal - 1] + HiddenField[vertical + 1][horizontal - 1] + HiddenField[vertical + 1][horizontal];
				}
			}
			else
			{
				if (horizontal == 0)
				{
					count = HiddenField[vertical - 1][horizontal] + HiddenField[vertical - 1][horizontal + 1] + HiddenField[vertical][horizontal + 1];
				}
				else if (horizontal > 0 && horizontal < size - 1)
				{
					count = HiddenField[vertical - 1][horizontal - 1] + HiddenField[vertical - 1][horizontal] + HiddenField[vertical - 1][horizontal + 1] + HiddenField[vertical][horizontal - 1] + HiddenField[vertical][horizontal + 1];
				}
				else
				{
					count = HiddenField[vertical - 1][horizontal - 1] + HiddenField[vertical][horizontal - 1] + HiddenField[vertical - 1][horizontal];
				}
			}

			MinaBoard[vertical][horizontal] = char(count + 48);// 0 в ascii code это 48
		}

		horizontal++;

		if (horizontal == size && vertical + 1 == size)
		{
			flag = false;
		}

		if (horizontal == size)
		{
			horizontal = 0;
			vertical++;
		}
	} while (flag);


	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (MinaBoard[i][j] == '0')
			{
				MinaBoard[i][j] = ' '; // опусташаем ячейки где написано ноль (для красоты)
			}
		}
	}
}

bool Check_coordinats(size_t size, char& vertical, short horizontal)
{

	// проверяем правтльно ли введены координаты 

	if (char(vertical - 32) >= 65 && char(vertical - 32) < (65 + size))
	{
		vertical -= 32;
	}

	if (!(vertical >= 65 && vertical < (65 + size)))
	{
		return false;
	}

	if (!(horizontal >= 0 && horizontal < size))
	{
		return false;
	}

	return true;
}

void Display_GameField(size_t size, char** Field, bool language, short& mines)
{
	SEPARATOR_LINE;
	printf("\x1B[31m\033[0");

	INDENT_space(52);
	if (!language) std::cout << "Оставшиеся мины =>";
	else std::cout << "Remaining mines => ";
	std::cout << mines << ' ' << (char)2;
	EndLine;

	printf("\x1B[31m\033[0m");
	char vertical_coordinates = 65; // Чтобы добавить вертикальные координаты, например буква ('A', 'B'...)
	SEPARATOR_LINE;

	if (size == 10)
	{
		INDENT_(30 - size / 2);
	}
	else if (size == 15)
	{
		INDENT_(25 - size / 2);
	}
	else
	{
		INDENT_(20 - size / 2);
	}

	for (int i = 0; i < size;) // Чтобы добавить горизонтальные координаты, например (1, 2, 3, 4...)
	{
		if (i > 8)
		{
			std::cout << i++ << "  ";
		}
		else
		{
			std::cout << i++ << "   ";
		}
	}

	EndLine; SEPARATOR_LINE;

	for (int i = 0; i < size; i++)
	{
		if (size == 10)
		{
			INDENT_(25 - size / 2);
			std::cout << (char)(vertical_coordinates + i) << " |  ";
		}
		else if (size == 15)
		{
			INDENT_(20 - size / 2);
			std::cout << (char)(vertical_coordinates + i) << " |  ";
		}
		else
		{
			INDENT_(15 - size / 2);
			std::cout << (char)(vertical_coordinates + i) << " |  ";
		}

		for (int j = 0; j < size; j++)
		{
			if (j + 1 == size)
			{
				std::cout << Field[i][j] << "  | " << (char)(vertical_coordinates + i);
			}
			else
			{
				std::cout << Field[i][j] << "   ";
			}
		}
		EndLine;
	}
	SEPARATOR_LINE;

	if (size == 10)
	{
		INDENT_(30 - size / 2);
	}
	else if (size == 15)
	{
		INDENT_(25 - size / 2);
	}
	else
	{
		INDENT_(20 - size / 2);
	}

	for (int i = 0; i < size;) // Чтобы добавить горизонтальные координаты, например (1, 2, 3, 4...)
	{
		if (i > 8)
		{
			std::cout << i++ << "  ";
		}
		else
		{
			std::cout << i++ << "   ";
		}
	}

	EndLine;
}

bool IsWinner(size_t size, char** Field, char** MinaBoard)
{
	// проверяем на победу(опусташение всех ячеек без мин)

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (Field[i][j] != MinaBoard[i][j])
			{
				if (!(Field[i][j] == 33 && MinaBoard[i][j] == 2))
				{
					return false;
				}
			}
		}
	}
	return true;
}

void MakeVerticalSpace(short vertical, short horizontal, size_t size, char** Field, char** MinaBoard)
{
	// Up

	for (int i = vertical; i >= 0; )
	{
		if (MinaBoard[i][horizontal] == ' ')
		{
			Field[i][horizontal] = ' ';
			if (vertical - 1 >= 0)
			{
				if (MinaBoard[i][horizontal - 1] >= 49 && MinaBoard[i][horizontal - 1] <= 57)
				{
					Field[i][horizontal - 1] = MinaBoard[i][horizontal - 1];
				}

			}
			if (vertical + 1 < size)
			{
				if (MinaBoard[i][horizontal + 1] >= 49 && MinaBoard[i][horizontal + 1] <= 57)
				{
					Field[i][horizontal + 1] = MinaBoard[i][horizontal + 1];
				}
			}
			i--;
		}
		else if (MinaBoard[i][horizontal] >= 49 && MinaBoard[i][horizontal] <= 57)
		{
			Field[i][horizontal] = MinaBoard[i][horizontal];
			break;
		}

	}

	// Down

	for (int i = vertical; i < size; )
	{
		if (MinaBoard[i][horizontal] == ' ')
		{
			Field[i][horizontal] = ' ';
			if (vertical - 1 >= 0)
			{
				if (MinaBoard[i][horizontal - 1] >= 49 && MinaBoard[i][horizontal - 1] <= 57)
				{
					Field[i][horizontal - 1] = MinaBoard[i][horizontal - 1];
				}

			}
			if (vertical + 1 < size)
			{
				if (MinaBoard[i][horizontal + 1] >= 49 && MinaBoard[i][horizontal + 1] <= 57)
				{
					Field[i][horizontal + 1] = MinaBoard[i][horizontal + 1];
				}

			}
			i++;
		}
		else if (MinaBoard[i][horizontal] >= 49 && MinaBoard[i][horizontal] <= 57)
		{
			Field[i][horizontal] = MinaBoard[i][horizontal];
			break;
		}


	}
}
void MakeHorizontalSpace(short vertical, short horizontal, size_t size, char** Field, char** MinaBoard)
{
	// Right

	for (int j = horizontal; j < size; )
	{

		if (MinaBoard[vertical][j] == ' ')
		{
			Field[vertical][j] = ' ';

			if (vertical - 1 >= 0)
			{
				if (MinaBoard[vertical - 1][j] >= 49 && MinaBoard[vertical - 1][j] <= 57)
				{
					Field[vertical - 1][j] = MinaBoard[vertical - 1][j];
				}
			}
			if (vertical + 1 < size)
			{
				if (MinaBoard[vertical + 1][j] >= 49 && MinaBoard[vertical + 1][j] <= 57)
				{
					Field[vertical + 1][j] = MinaBoard[vertical + 1][j];
				}
			}
			j++;
		}
		else if (MinaBoard[vertical][j] >= 49 && MinaBoard[vertical][j] <= 57)
		{
			Field[vertical][j] = MinaBoard[vertical][j];
			break;
		}


	}

	// Left

	for (int j = horizontal; j >= 0; )
	{

		if (MinaBoard[vertical][j] == ' ')
		{
			Field[vertical][j] = ' ';
			if (vertical - 1 >= 0)
			{
				if (MinaBoard[vertical - 1][j] >= 49 && MinaBoard[vertical - 1][j] <= 57)
				{
					Field[vertical - 1][j] = MinaBoard[vertical - 1][j];
				}

			}
			if (vertical + 1 < size)
			{
				if (MinaBoard[vertical + 1][j] >= 49 && MinaBoard[vertical + 1][j] <= 57)
				{
					Field[vertical + 1][j] = MinaBoard[vertical + 1][j];
				}
			}

			j--;
		}
		else if (MinaBoard[vertical][j] >= 49 && MinaBoard[vertical][j] <= 57)
		{
			Field[vertical][j] = MinaBoard[vertical][j];
			break;
		}

	}
}
void MakeDiaqonalSpace(short vertical_coor, short horizontal_coor, size_t size, char** Field, char** MinaBoard)
{
	// Right diagonal

	for (int i = vertical_coor, j = horizontal_coor; i >= 0 && j < size;)
	{
		if (MinaBoard[i][j] == ' ')
		{
			Field[i][j] = ' ';
			MakeVerticalSpace(i, j, size, Field, MinaBoard);
			MakeHorizontalSpace(i, j, size, Field, MinaBoard);
			i--;
			j++;
		}
		else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
		{
			Field[i][j] = MinaBoard[i][j];
			break;
		}
	}

	// Left diagonal

	for (int i = vertical_coor, j = horizontal_coor; i < size && j >= 0;)
	{
		if (MinaBoard[i][j] == ' ')
		{
			Field[i][j] = ' ';
			MakeVerticalSpace(i, j, size, Field, MinaBoard);
			MakeHorizontalSpace(i, j, size, Field, MinaBoard);
			i++; j--;
		}
		else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
		{
			Field[i][j] = MinaBoard[i][j];
			break;
		}
	}

	for (int i = vertical_coor, j = horizontal_coor; i < size && j < size;)
	{
		if (MinaBoard[i][j] == ' ')
		{
			Field[i][j] = ' ';
			MakeVerticalSpace(i, j, size, Field, MinaBoard);
			MakeHorizontalSpace(i, j, size, Field, MinaBoard);
			i++;
			j++;
		}
		else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
		{
			Field[i][j] = MinaBoard[i][j];
			break;
		}
	}

	for (int i = vertical_coor, j = horizontal_coor; i >= 0 && j >= 0;)
	{
		if (MinaBoard[i][j] == ' ')
		{
			Field[i][j] = ' ';
			MakeVerticalSpace(i, j, size, Field, MinaBoard);
			MakeHorizontalSpace(i, j, size, Field, MinaBoard);
			i--;
			j--;
		}
		else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
		{
			Field[i][j] = MinaBoard[i][j];
			break;
		}
	}
}
void MakeSpace(short vertical, short horizontal, size_t size, char** Field, char** MinaBoard)
{
	int iteration = 3;
	while (iteration--)
	{
		MakeDiaqonalSpace(vertical, horizontal, size, Field, MinaBoard);

		for (int i = vertical; i < size; i++)
		{
			if (MinaBoard[i][horizontal] == ' ')
			{
				for (int j = horizontal; j < size; j++)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}

				for (int j = horizontal; j >= 0; j--)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}
			}
			else if (MinaBoard[i][horizontal] >= 49 && MinaBoard[i][horizontal] <= 57)
			{
				Field[i][horizontal] = MinaBoard[i][horizontal];
				break;
			}
		}

		for (int i = vertical; i >= 0; i--)
		{
			if (MinaBoard[i][horizontal] == ' ')
			{
				for (int j = horizontal; j < size; j++)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}

				for (int j = horizontal; j >= 0; j--)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}
			}
			else if (MinaBoard[i][horizontal] >= 49 && MinaBoard[i][horizontal] <= 57)
			{
				Field[i][horizontal] = MinaBoard[i][horizontal];
				break;
			}
		}

		for (int j = horizontal; j < size; j++)
		{
			if (MinaBoard[vertical][j] == ' ')
			{
				for (int i = vertical; i < size; i++)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}

				for (int i = vertical; i >= 0; i--)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}
			}
			else if (MinaBoard[vertical][j] >= 49 && MinaBoard[vertical][j] <= 57)
			{
				Field[vertical][j] = MinaBoard[vertical][j];
				break;
			}
		}

		for (int j = horizontal; j >= 0; j--)
		{
			if (MinaBoard[vertical][j] == ' ')
			{
				for (int i = vertical; i < size; i++)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}

				for (int i = vertical; i >= 0; i--)
				{
					if (MinaBoard[i][j] == ' ')
					{
						Field[i][j] = ' ';
					}
					else if (MinaBoard[i][j] >= 49 && MinaBoard[i][j] <= 57)
					{
						Field[i][j] = MinaBoard[i][j];
						break;
					}
				}
			}
			else if (MinaBoard[vertical][j] >= 49 && MinaBoard[vertical][j] <= 57)
			{
				Field[vertical][j] = MinaBoard[vertical][j];
				break;
			}
		}
	}

	MakeDiaqonalSpace(vertical, horizontal, size, Field, MinaBoard);
}

bool Impact(short vertical, short horizontal, size_t size, char** Field, char** MinaBoard)
{
	// Воздействие на конкретную координату

	if (MinaBoard[vertical][horizontal] == 2) return false; // Вы задели мину

	else if (MinaBoard[vertical][horizontal] == ' ')// Вы задели пустоту
	{
		MakeSpace(vertical, horizontal, size, Field, MinaBoard); // Опусташаем все координаты вокруг
	}

	else
	{
		Field[vertical][horizontal] = MinaBoard[vertical][horizontal]; // Вы задели цифру и мы это присваеваем
	}

	return true;
}

void Deleting_GameOptions(size_t size, char** Field, char** MinaBoard, bool** HiddenField)
{
	Delete_array(size, Field);
	Delete_array(size, MinaBoard);
	Delete_array(size, HiddenField);
}

// main.cpp

#include "Minesweeper.h"
#define DEBUG 0 // ADMIN MODE

int main()
{
	setlocale(LC_ALL, "Russian");
	srand(time(nullptr));
	Black_Blue;

	// Изменяем размер символов
	CONSOLE_FONT_INFOEX cfi;
	{
		cfi.cbSize = sizeof(cfi);
		cfi.nFont = 0;
		cfi.dwFontSize.X = 0;                   // Width of each character in the font
		cfi.dwFontSize.Y = 21;                  // Height
		cfi.FontFamily = FF_DONTCARE;
		cfi.FontWeight = FW_NORMAL;
		//std::wcscpy(cfi.FaceName, L"Consolas"); // Choose your font
		SetCurrentConsoleFontEx(GetStdHandle(STD_OUTPUT_HANDLE), FALSE, &cfi);
	}

	bool flag;   // Повторение цикла при ошибках
	short Game = 0; // Повторение игрового цикла

	size_t size = 10; // Размер поля
	short mines = 10;  // Количество мин на игровом поле.

	short language = 1;  // Выбор языка
	short op = 0; // Опции

	EpilepsyTime("Minesweeper game is Loading."); // Забавная загрузка игры

	do
	{
		flag = true;
		Game = true;

		// Создаем игровое поле по параметрам, выбранным пользователями
		{
			// Выбору языка
			{

				SEPARATOR_LINE;

				EndLine; INDENT_(90); std::cout << " Select Language:"; EndLine; EndLine;

				SEPARATOR_LINE;

				INDENT_space(75); std::cout << " 0. Russian"; EndLine; // Russian
				INDENT_space(75); std::cout << " 1. English"; EndLine; // English

				SEPARATOR_Input(82);
				language = _getch(); EndLine;
				language -= 48;

				if (language != 0 && language != 1)
				{
					SEPARATOR_LINE;

					INDENT_(90); std::cout << " Default Russian"; EndLine;

					language = 0;
				}
			}

			Clear_Field;
			SEPARATOR_LINE;

			// Выбор размера поля
			{
				do
				{
					if (!language)
					{
						EndLine; INDENT_space(65); std::cout << " Выберите размер игрового поля:"; EndLine; EndLine;
					}
					else
					{
						EndLine; INDENT_space(62); std::cout << " Select the size of the playing field:"; EndLine; EndLine;
					}

					SEPARATOR_LINE;

					INDENT_space(74); std::cout << " 1. 10 x 10"; EndLine;// Ten
					INDENT_space(74); std::cout << " 2. 15 x 15"; EndLine; // Fifteen
					INDENT_space(74); std::cout << " 3. 20 x 20"; EndLine; // Fifteen

					SEPARATOR_Input(82);
					op = _getch(); EndLine;
					op -= 48;

					Clear_Field;
					SEPARATOR_LINE;

					switch (op)
					{
						case Ten:
							{
								size = 10;
								// Выбор Игрового режима
								{
									do
									{
										if (!language)
										{
											EndLine; INDENT_(93); std::cout << " Выберите игровой режим:"; EndLine; EndLine;

											SEPARATOR_LINE;

											INDENT_space(70); std::cout << " 1. Легкий  (10 мин )"; EndLine; // Easy
											INDENT_space(70); std::cout << " 2. Средний (20 мин )"; EndLine; // Medium
											INDENT_space(70); std::cout << " 3. Сложный (30 мин )"; EndLine; // Hard
										}
										else
										{
											INDENT_(89); std::cout << " Select a Game Mode:"; EndLine;

											SEPARATOR_LINE;

											INDENT_space(70); std::cout << " 1. Easy   (10 mines)"; EndLine; // Easy
											INDENT_space(70); std::cout << " 2. Medium (20 mines)"; EndLine; // Medium
											INDENT_space(70); std::cout << " 3. Hard   (30 mines)"; EndLine; // Hard
										}

										SEPARATOR_Input(84);
										op = _getch(); EndLine;
										op -= 48;

										Clear_Field;
										SEPARATOR_LINE;

										switch (op)
										{
											case Easy:
												{
													mines = 10;
													flag = false;
													break;
												}
											case Medium:
												{
													mines = 20;
													flag = false;
													break;
												}
											case Hard:
												{
													mines = 30;
													flag = false;
													break;
												}
											default:
												{
													INDENT_(105);
													if (!language) std::cout << "[ERROR]Вы ввели что-то не так, попробуйте еще раз!";
													else std::cout << "[ERROR]You entered something wrong, please try again!";
													EndLine;

													Wrong();

													Clear_Field;
													Black_Blue;
													SEPARATOR_LINE;
												}
										}
									} while (flag);

									break;
								}
							}
						case Fifteen:
							{
								size = 15;
								// Выбор Игрового режима
								{
									do
									{
										if (!language)
										{
											EndLine; INDENT_(93); std::cout << " Выберите игровой режим:"; EndLine;  EndLine;

											SEPARATOR_LINE;

											INDENT_space(70); std::cout << " 1. Легкий  (20 мин )"; EndLine; // Easy
											INDENT_space(70); std::cout << " 2. Средний (45 мин )"; EndLine; // Medium
											INDENT_space(70); std::cout << " 3. Сложный (70 мин )"; EndLine; // Hard
										}
										else
										{
											EndLine; INDENT_(89); std::cout << " Select a Game Mode:"; EndLine; EndLine;

											SEPARATOR_LINE;

											INDENT_space(70); std::cout << " 1. Easy   (20 mines)"; EndLine; // Easy
											INDENT_space(70); std::cout << " 2. Medium (45 mines)"; EndLine; // Medium
											INDENT_space(70); std::cout << " 3. Hard   (70 mines)"; EndLine; // Hard
										}

										SEPARATOR_Input(82);
										op = _getch(); EndLine;
										op -= 48;

										Clear_Field;
										SEPARATOR_LINE;

										switch (op)
										{
											case Easy:
												{
													mines = 20;
													flag = false;
													break;
												}
											case Medium:
												{
													mines = 45;
													flag = false;
													break;
												}
											case Hard:
												{
													mines = 70;
													flag = false;
													break;
												}
											default:
												{
													INDENT_(105);
													if (!language) std::cout << "[ERROR]Вы ввели что-то не так, попробуйте еще раз!";
													else std::cout << "[ERROR]You entered something wrong, please try again!";
													EndLine;

													Wrong();

													Clear_Field;
													Black_Blue;
													SEPARATOR_LINE;
												}
										}
									} while (flag);
									break;
								}
							}
						case Twenty:
							{
								size = 20;
								// Выбор Игрового режима
								{
									do
									{
										if (!language)
										{
											EndLine; INDENT_(93); std::cout << " Выберите игровой режим:"; EndLine; EndLine;

											SEPARATOR_LINE;

											INDENT_space(70); std::cout << " 1. Легкий  (50 мин )"; EndLine; // Easy
											INDENT_space(70); std::cout << " 2. Средний (100 мин )"; EndLine; // Medium
											INDENT_space(70); std::cout << " 3. Сложный (200 мин )"; EndLine; // Hard
										}
										else
										{
											EndLine; INDENT_(89); std::cout << " Select a Game Mode:"; EndLine; EndLine;

											SEPARATOR_LINE;

											INDENT_space(69); std::cout << " 1. Easy   (50 mines)"; EndLine;// Easy
											INDENT_space(69); std::cout << " 2. Medium (100 mines)"; EndLine; // Medium
											INDENT_space(69); std::cout << " 3. Hard   (200 mines)"; EndLine; // Hard
										}

										SEPARATOR_Input(82);
										op = _getch(); EndLine;
										op -= 48;

										Clear_Field;
										SEPARATOR_LINE;

										switch (op)
										{
											case Easy:
												{
													mines = 50;
													flag = false;
													break;
												}
											case Medium:
												{
													mines = 100;
													flag = false;
													break;
												}
											case Hard:
												{
													mines = 200;
													flag = false;
													break;
												}
											default:
												{
													INDENT_(105);
													if (!language) std::cout << "[ERROR]Вы ввели что-то не так, попробуйте еще раз!";
													else std::cout << "[ERROR]You entered something wrong, please try again!";
													EndLine;

													Wrong();

													Clear_Field;
													Black_Blue;
													SEPARATOR_LINE;
												}
										}
									} while (flag);
									break;
								}
							}

						default:
							{
								INDENT_(105);
								if (!language) std::cout << "[ERROR]Вы ввели что-то не так, попробуйте еще раз!";
								else std::cout << "[ERROR]You entered something wrong, please try again!";
								EndLine;

								Wrong();
								Clear_Field;
								Black_Blue;
								SEPARATOR_LINE;
							}
					}
				} while (flag);
			}
		}

		Clear_Field;
		SEPARATOR_LINE;
		Black_White;

		// Заголовок игры по выбору языка
		switch (language)
		{
			case Russian:
				{
					SEPARATOR_HASHTAG;
					SEPARATOR_HASHTAG; EndLine;

					INDENT_space(68); std::cout << (char)176; printf("\x1B[31mДобро пожаловать в игру \"Сапер\"\033[0m"); std::cout << (char)176;

					EndLine;

					INDENT_space(45); std::cout << " Ваша цель вскрыть пустые ячейки, не вскрыв при этом ни одной, содержащей мину."; EndLine;

					EndLine;

					INDENT_space(74); printf("\x1B[31mПравила игры :\033[0m"); EndLine;

					EndLine;

					INDENT_space(45); std::cout << " Выбрать определенную координату на поле. При выборе ячейки, она открывается. "; EndLine;
					INDENT_space(58); std::cout << " Если в ней находится мина, то игрок проигрывает. "; EndLine; EndLine;
					INDENT_space(17); std::cout << " Если в самой ячейке мины нет, но есть мины в соседних ячейках, то отображается число, соответствующее количеству мин в соседних ячейках."; EndLine;
					INDENT_space(30); std::cout << " Несколько соседних ячеек с числами указывают на одни и те же мины, что позволяет точно определить опасные клетки. "; EndLine;
					INDENT_space(35); std::cout << " Если ни в самой ячейке, ни в соседних с ней ячейках нет мин, то открываются все соседние пустые ячейки. "; EndLine;

					EndLine;

					INDENT_space(54); std::cout << " Для удобства, ячейки с минами можно помечать флажками."; EndLine;
					INDENT_space(48); std::cout << " Игра выигрывается, как только открыты все ячейки, не содержащие мин."; EndLine;

					EndLine;

					INDENT_space(74); printf("\x1B[34mУдачной вам игры!\033[0m"); EndLine;

					EndLine;
					SEPARATOR_HASHTAG;
					SEPARATOR_HASHTAG;

					Sleep(3000);
					EpilepsyTime("Запуск игры.");
					break;
				}

			case English:
				{
					SEPARATOR_HASHTAG;
					SEPARATOR_HASHTAG;
					EndLine;

					INDENT_space(68); std::cout << (char)176; printf("\x1B[31mWelcome to the game \"Minesweeper\"\033[0m"); std::cout << (char)176;

					EndLine;

					INDENT_space(50); std::cout << " Your goal is to open empty cells without opening any containing mines."; EndLine;

					EndLine;

					INDENT_space(72); 	printf("\x1B[31mRules of the game :\033[0m"); EndLine;

					EndLine;

					INDENT_space(45); std::cout << " Select a specific coordinate on the field. When you select a cell, it opens. "; EndLine;
					INDENT_space(58); std::cout << " If there is a mine in it, the player loses. "; EndLine; EndLine;
					INDENT_space(2);  std::cout << " If there is no mine in the cell itself, but there are mines in neighboring cells, then the number corresponding to the number of mines in neighboring cells is displayed."; EndLine;
					INDENT_space(37); std::cout << " Several adjacent numbered slots represent the same mines, allowing you to pinpoint dangerous slots. "; EndLine;
					INDENT_space(23); std::cout << " If there are no mines in either the cell itself or the cells adjacent to it, then all adjacent empty cells are opened. "; EndLine;

					EndLine;

					INDENT_space(49); std::cout << " For convenience, the slots of the shafts can be marked with flags."; EndLine;
					INDENT_space(46); std::cout << " The game is won as soon as all cells that do not contain mines are open."; EndLine; EndLine;

					INDENT_space(70); printf("\x1B[34mGood luck with your game!\033[0m"); EndLine;

					EndLine;
					SEPARATOR_HASHTAG;
					SEPARATOR_HASHTAG;

					Sleep(3000);
					EpilepsyTime("Launching the game.");
					break;
				}
		}

		bool** HiddenField = new bool* [size]; // Поле, где отображаются мины
		char** GameField = new char* [size];  // Игровые поля для геймера
		char** MinaBoard = new char* [size]; // Поле, где ставятся мины и числа

		Create_GameField(size, GameField, MinaBoard, HiddenField); // Создаем игровое поле

		bool _continue = 1; // Чтобы продолжить игровой цикл
		bool false_value = 1; // При вводе неправильно цифры избежать сгенерирование массива
		short horizontal_coordinat; // Горизонтальные координаты, например (1, 2, 3, 4...)
		char  vertical_coordinat;  // Вертикальные координаты, например буквы ('A', 'B'...)
		bool isCreated = 0; // Ставит мины после выдачи координат пользователя (помогает не проиграть с первого раза)

		// Изменяем размер шрифта
		{
			if (size == 10)
			{
				cfi.dwFontSize.Y = 34;

			}
			else if (size == 15)
			{
				cfi.dwFontSize.Y = 32;

			}
			else
			{
				cfi.dwFontSize.Y = 30;
			}
			cfi.FontFamily = FF_DONTCARE;
			cfi.FontWeight = FW_NORMAL;
			SetCurrentConsoleFontEx(GetStdHandle(STD_OUTPUT_HANDLE), FALSE, &cfi);
		}

		// Игра
		{
			SuperMario();
			clock_t Begin = clock(); // начало игры или же начала Таймера
			do
			{
				Sleep(250);
				EndLine;
				Black_Blue;

				Display_GameField(size, GameField, language, mines); // Отображение игрового поля
				if (DEBUG) Display_GameField(size, MinaBoard, language, mines); //  =>  чтобы увидеть поле с минами . Привилегия для админа

				if (!IsWinner(size, GameField, MinaBoard))
				{
					printf("\x1B[31m\033[0");
					if (!language)
					{
						SEPARATOR_LINE;
						INDENT_(48); std::cout << " Выберите :"; EndLine;
						SEPARATOR_LINE;

						INDENT_space(35); std::cout << " 0. Выбрать ячейку"; EndLine; // Select_cell
						INDENT_space(35); std::cout << " 1. Поставить флаг"; EndLine; // Put_flag
						INDENT_space(35); std::cout << " 2. Снять флаг "; EndLine; // Remove_flag
					}
					else
					{
						SEPARATOR_LINE;
						INDENT_(48); std::cout << " Select :"; EndLine;
						SEPARATOR_LINE;

						INDENT_space(35); std::cout << " 0. Select cell"; EndLine; // Select_cell
						INDENT_space(35); std::cout << " 1. Put a flag"; EndLine; // Put_flag
						INDENT_space(35); std::cout << " 2. Remove a flag"; EndLine; // Remove_flag
					}

					SEPARATOR_Input(44);

					op = _getch(); EndLine;
					op -= 48;

					if (op != 0 && op != 1 && op != 2)
					{
						op = 0;
						SEPARATOR_LINE;
						INDENT_(50); std::cout << " Default 0"; EndLine; Sleep(150);
					}

					Clear_Field;
					Black_Blue;

					Display_GameField(size, GameField, language, mines); // Отображение игрового поля

					flag = true;
					do
					{
						printf("\x1B[31m\033[0");
						SEPARATOR_LINE;

						INDENT_space(37);
						if (!language) printf("\x1B[31mПожалуйста стреляйте\033[0");
						else  printf("\x1B[31mPlease shoot!\033[0");

						EndLine;
						SEPARATOR_LINE;
						EndLine;

						if (!language) printf("\x1B[31mВведите вертикальную координату (например, A) => \033[0");
						else  printf("\x1B[31mEnter the vertical coordinate (e.g. A) => \033[0");
						vertical_coordinat = _getch(); EndLine;
						EndLine;

						if (!language) printf("\x1B[31mВведите горизонтальную координату (например, 0) => \033[0");
						else printf("\x1B[31mEnter the horizontal coordinate (e.g. 0) => \033[0");
						std::cin >> horizontal_coordinat;

						if (std::cin.fail())
						{
							EndLine;
							false_value = 0;
							INDENT_space(65);
							std::cin.clear(); // сбрасывает все биты потока, тоесть поток становится "хорошим"
							std::cin.ignore(std::cin.rdbuf()->in_avail());//защита от дурака при вводе букв вместо числа
							std::cin.sync();
							Wrong();
							horizontal_coordinat = size;
						}
						else
						{
							false_value = true;
						}

						// Проверка координатов на ошибку
						if (!Check_coordinats(size, vertical_coordinat, horizontal_coordinat))
						{
							flag = false;
							Clear_Field;

							SEPARATOR_LINE;

							INDENT_(65);

							if (!language) std::cout << "[ERROR]Вы ввели что-то не так, попробуйте еще раз!";
							else std::cout << "[ERROR]You entered something wrong, please try again!";

							Wrong();

							Clear_Field;

							Black_Blue;

							Display_GameField(size, GameField, language, mines); // Отображение игрового поля
						}
						else
						{
							flag = true;
						}

					} while (!flag);

					if (!isCreated && false_value) // сгенерируем игру с первого ввода правильных координат
					{
						SetMina(mines, size, MinaBoard, HiddenField, vertical_coordinat - 65, horizontal_coordinat);
						isCreated = true;
					}

					switch (op)
					{
						case Select_cell: // просто стреляем в ячейку
							{
								if (GameField[vertical_coordinat - 65][horizontal_coordinat] == (char)2)
								{
									_continue = Impact(vertical_coordinat - 65, horizontal_coordinat, size, GameField, MinaBoard);
								}
								else
								{
									Clear_Field;
									SEPARATOR_LINE;

									INDENT_(65);
									if (!language) std::cout << "[ERROR]Повтор ячейки, выберите другой !";
									else std::cout << "[ERROR]Cell repeat, choose another!";

									EndLine;
									Wrong();
									SEPARATOR_LINE;
								}

								break;
							}

						case Put_flag: // ставим флажок
							{
								if (GameField[vertical_coordinat - 65][horizontal_coordinat] == (char)2)
								{
									GameField[vertical_coordinat - 65][horizontal_coordinat] = (char)33;
									mines--;
								}

								else
								{
									Clear_Field;
									SEPARATOR_LINE;

									INDENT_(65);
									if (!language) std::cout << "[ERROR]Повтор ячейки, выберите другой !";
									else std::cout << "[ERROR]Cell repeat, choose another!";

									EndLine;
									Wrong();
									SEPARATOR_LINE;
								}
								break;
							}
						case Remove_flag: // убираем флажок
							{
								if (GameField[vertical_coordinat - 65][horizontal_coordinat] == (char)33)
								{
									GameField[vertical_coordinat - 65][horizontal_coordinat] = (char)2;
									mines++;
								}
								else
								{
									Clear_Field;
									SEPARATOR_LINE;

									INDENT_(65);
									if (!language) std::cout << "[ERROR]В ячейке уже нет флажка, выбирайте другой!";
									else std::cout << "[ERROR]The checkbox is no longer in the cell, choose another!";
									EndLine;
									Wrong();

									Black_Blue;
								}
								break;
							}
					}
					Clear_Field;
				}
				else
				{
					// Если пользователь выиграл

					Clear_Field;

					clock_t End = clock(); // таймер подходит к концу

					SEPARATOR_LINE;

					Display_GameField(size, MinaBoard, language, mines); // Отображение минного поля

					SEPARATOR_LINE;
					int minutes = ((End - Begin) / CLOCKS_PER_SEC) / 60;
					int seconds = ((double)(End - Begin) / CLOCKS_PER_SEC) - minutes * 60;

					SEPARATOR_LINE;
					INDENT_(45);
					if (!language) std::cout << "Ваше время =>  ";
					else std::cout << "Time =>  ";
					std::cout << minutes << "m " << seconds << " s";

					EndLine;
					SEPARATOR_LINE;

					INDENT_(45);
					if (!language) std::cout << "Вы выиграли! ";
					else std::cout << "You win!";

					EndLine;
					SEPARATOR_LINE;
					Sleep(4000);
					Clear_Field;
					Finish_Game(1);
					Clear_Field;
					_continue = false;
				}

			} while (_continue);

			if (!IsWinner(size, GameField, MinaBoard))
			{
				// При проигрыши
				White_Red;
				SEPARATOR_LINE;

				Display_GameField(size, MinaBoard, language, mines); // Отображение минного поля

				SEPARATOR_LINE;

				INDENT_(45);
				if (!language) std::cout << "Вы проиграли!";
				else std::cout << "You lose!";

				EndLine;
				SEPARATOR_LINE;
				Wrong();
				White_Red;

				Sleep(4000);
				Clear_Field;
				Black_White;
				Finish_Game(0);
				Clear_Field;
			}
		}

		Sleep(1000);
		Black_Blue;

		// Изменяем размер Шрифта
		{
			cfi.dwFontSize.Y = 21;                  // Height
			cfi.FontFamily = FF_DONTCARE;
			cfi.FontWeight = FW_NORMAL;
			SetCurrentConsoleFontEx(GetStdHandle(STD_OUTPUT_HANDLE), FALSE, &cfi);
		}

		// Запрос на повторение игры
		{
			Clear_Field;
			if (!language)
			{
				SEPARATOR_LINE;
				EndLine; INDENT_(100); std::cout << "Вы хотите начать новую игру?"; EndLine; EndLine;
				SEPARATOR_LINE;

				INDENT_space(80); std::cout << " 0. Нет"; EndLine; // No
				INDENT_space(80); std::cout << " 1. Да"; EndLine; // Yes

				SEPARATOR_Input(84);
				Game = _getch(); EndLine;
				Game -= 48;

				SEPARATOR_LINE;

				if (Game != 0 && Game != 1)
				{
					INDENT_(92); std::cout << " По умолчанию Нет!"; EndLine;
					SEPARATOR_LINE;

					Game = 0;
				}

				if (!Game)
				{
					INDENT_(90); std::cout << " До свидания!"; EndLine;
					SEPARATOR_LINE;
				}
				else
				{
					Clear_Field;
					EpilepsyTime("Игра «Сапер» загружается.");
				}
			}
			else
			{
				SEPARATOR_LINE;
				EndLine; INDENT_(100); std::cout << " Do you want to start a new game?"; EndLine;  EndLine;
				SEPARATOR_LINE;

				INDENT_space(80); std::cout << " 0. No"; EndLine; // No
				INDENT_space(80); std::cout << " 1. Yes"; EndLine; // Yes

				SEPARATOR_Input(85);
				Game = _getch(); EndLine;
				Game -= 48;

				SEPARATOR_LINE;

				if (Game != 0 && Game != 1)
				{
					INDENT_(89); std::cout << " Default No!"; EndLine;
					SEPARATOR_LINE;

					Game = 0;
				}

				if (!Game)
				{
					INDENT_(88); std::cout << " Goodbye!"; EndLine;
					SEPARATOR_LINE;
					SEPARATOR_LINE;
					MissionImposibble_sound();
				}
				else
				{
					EpilepsyTime("Minesweeper game is Loading.");
				}
			}
		}

		Deleting_GameOptions(size, GameField, MinaBoard, HiddenField); // Удаление параметров игры

	} while (Game);
}


